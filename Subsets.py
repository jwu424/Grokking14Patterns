# Given a set with distinct elements, find all of its distinct subsets.
# Time: O(2^N)
def find_subsets(nums):
    subset = [[]]
    for elem in nums:
        n = len(subset)
        for i in range(n):
            res.append(res[i] + [curNum])
    return subset


# Given a set of numbers that might contain duplicates, find all of its distinct subsets.
# Time: O(2^N)
def find_subsets(nums):
    nums.sort()
    res = []
    res.append([])
    startIndex, endIndex = 0, 0
    for i in range(len(nums)):
        startIndex = 0
        if i > 0 and nums[i] == nums[i-1]:
            startIndex = endIndex + 1
        endIndex = len(res) - 1
        for j in range(startIndex, endIndex+1):
            res.append(res[j] + [nums[i]])
    return res

# Given a set of distinct numbers, find all of its permutations.
# Time: O(N*N!)

#### Method 1
def find_permutations(nums):
    res = []
    find_per_resc(nums, [], res)
    return res

def find_per_resc(nums, temp, res):
    if not nums:
        res.append(temp)
    for i in range(len(nums)):
        find_per_resc(nums[:i] + nums[i+1:], temp+[nums[i]], res)

#### Method 2
def find_permutations(nums):
    res = []
    generate_per(nums, 0, [], res)
    return res

def generate_per(nums, index, curPer, res):
    if index == len(nums):
        res.append(curPer)
    else:
        for i in range(len(curPer)+1):
            newPer = list(curPer)
            newPer.insert(i, nums[index])
            generate_per(nums, index+1, newPer, res)

#### Method 3
from collections import deque
def find_permutations(nums):
    numsLength = len(nums)
    res = []
    permutations = deque()
    permutations.append([])
    for curNum in nums:
        n = len(permutations)
        for _ in range(n):
            oldPerm = permutations.popleft()
            for j in range(len(oldPerm)+1):
                newPer = list(oldPerm)
                newPer.insert(j, curNum)
                if len(newPer) == numsLength:
                    res.append(newPer)
                else:
                    permutations.append(newPer)
    return res

# Given a string, find all of its permutations preserving the character sequence but changing case.
# O(N*2^N)
def find_letter_case_string_permutations(str):
    permutation = [str]
    for i in range(len(str)):
        if str[i].isalpha():
            n = len(permutation)
            for j in range(n):
                chs = list(permutation[j])
                chs[i] = chs[i].swapcase()
                permutation.append(''.join(chs))
    return permutation

# For a given number ‘N’, write a function to generate all combination of ‘N’ pairs of balanced parentheses.
# Time: O(N*2^N)
def generate_valid_parentheses(num):
    res = []
    parenthesesString = [0 for x in range(2*num)]
    generate_valid(num, 0, 0, parenthesesString, 0, res)
    return res

def generate_valid(num, openCount, closeCount, parenthesesString, index, res):
    if openCount == num and closeCount == nums:
        res.append(''.join(parenthesesString))
    else:
        if openCount < num:
            parenthesesString[index] = '('
            generate_valid(num, openCount+1, closeCount, parenthesesString, index+1, res)
        
        if openCount > closeCount:
            parenthesesString[index] = ')'
            generate_valid(num, openCount, closeCount+1, parenthesesString, index+1, res)


# Given a word, write a function to generate all of its unique generalized abbreviations.
# Generalized abbreviation of a word can be generated by replacing each substring of the word by the count of characters in the substring. 
# Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”. After replacing these substrings in the actual word by the count of characters we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.

# Time: O(N*2^N)
class AbbreviatedWord:
    def __init__(self, str, start, count):
        self.str = str
        self.start = start
        self.count = count


def generate_generalized_abbreviation(word):
    wordLen = len(word)
    res = []
    queue = deque()
    queue.append(AbbreviatedWord(list(), 0, 0))
    while queue:
        abWord = queue.popleft()
        if abWord.start == wordLen:
            if abWord.count != 0:
                abWord.str.append(str(abWord.count))
            res.append(''.join(abWord.str))
        else:
            queue.append(AbbreviatedWord(list(abWord.str), abWord.start+1, abWord.count+1))
            
            if abWord.count != 0:
                abWord.str.append(str(abWord.count))
            newWord = list(abWord.str)
            newWord.append(word[abWord.start])
            queue.append(AbbreviatedWord(newWord, abWord.start+1, 0))
    return res

####
def generate_generalized_abbreviation(word):
    res = []
    generate_rec(word, list(), 0, 0, res)
    return res

def generate_rec(word, abWord, start, count, res):
    if start == len(word):
        if count != 0:
            abWord.append(str(count))
        res.append(''.join(abWord))
    else:
        generate_rec(word, list(abWord), start+1, count+1, res)

        if count != 0:
            abWord.append(str(count))
        generate_rec(word, list(abWord)+[word[start]], start+1, 0, res)


# Given an expression containing digits and operations (+, -, *), find all possible ways in which the expression can be evaluated by grouping the numbers and operators using parentheses.
# Time: O(N*2^N)

def diff_ways_to_evaluate_expression(input):
    res = []
    if '+' not in input and '-' not in input and '*' not in input:
        res.append(int(input))
    else:
        for i in range(len(input)):
            char = input[i]
            if not char.isdigit():
                leftpart = diff_ways_to_evaluate_expression(input[:i])
                rightpart = diff_ways_to_evaluate_expression(input[i+1:])
                for part1 in leftpart:
                    for part2 in rightpart:
                        if char == '+':
                            res.append(part1 + part2)
                        elif char == '-':
                            res.append(part1 - part2)
                        elif char == '*':
                            res.append(part1 * part2)
    return res

# Using Memoization

def diff_ways_to_evaluate_expression(input):
    return diff_ways_to_evaluate_expression_rec({}, input)

def diff_ways_to_evaluate_expression_rec(map, input):
    if input in map:
        return map[input]
    res = []
    if '+' not in input and '-' not in input and '*' not in input:
        res.append(int(input))
    else:
        for i in range(len(input)):
            char = input[i]
            if not char.isdigit():
                leftpart = diff_ways_to_evaluate_expression_rec(map, input[:i])
                rightpart = diff_ways_to_evaluate_expression_rec(map, input[i+1:])
                for part1 in leftpart:
                    for part2 in rightpart:
                        if char == '+':
                            res.append(part1 + part2)
                        elif char == '-':
                            res.append(part1 - part2)
                        elif char == '*':
                            res.append(part1 * part2)
    map[input] = res
    return res


# Given a number ‘n’, write a function to return all structurally unique Binary Search Trees (BST) that can store values 1 to ‘n’?
# Time: O(N*2^N)
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
    
def find_unique_trees(n):
    if n <= 0:
        return []
    return find_unique_trees_resc(1, n)
    
def find_unique_trees_resc(start, end):
    res = []
    if start > end:
        res.append(None)
        return res
    for i in range(start, end+1):
        leftpart = find_unique_trees_resc(start, i-1)
        rightpart = find_unique_trees_resc(i+1, end)
        for left in leftpart:
            for right in rightpart:
                root = TreeNode(i)
                root.left = left
                root.right = right
                res.append(root)
    return res


# Given a number ‘n’, write a function to return the count of structurally unique Binary Search Trees (BST) that can store values 1 to ‘n’.
# Time: O(N*2^N)

def count_trees(n):
    if n <= 1:
        return 1
    count = 0
    for i in range(1, n+1):
        leftpart = count_trees(i-1)
        rightpart = count_trees(n - i)
        count += leftpart * rightpart
    return count

# Memoization

def count_trees(n):
    return count_tree_resc({}, n)

def count_tree_resc(map, n):
    if n in map:
        return map[n]
    if n <= 1:
        return 1
    count = 0
    for i in range(1, n+1):
        leftpart = count_tree_resc(map, i-1)
        rightpart = count_tree_resc(map, n - i)
        count += leftpart * rightpart
    map[n] = count
    return count